# AproxAlgolithm
## 1. 그리디 알고리즘
- 욕심쟁이 방법, 탐욕적 방법
- 최적화 문제(가능한 해들 중에 최대 또는 최소 해를 찾는 문제)를 해결
- 데이터간 관계 고려 X, 최대 또는 최소만을 선택(근시안적 선택)
- 선택을 절대로 번복 X
- 매우 단순한 편
![image](https://user-images.githubusercontent.com/80511265/114722898-27d5f580-9d75-11eb-9dea-3fa50bf6fec3.png)

* *__작업 스케줄링__*</br>
최소한의 기계 수로 주어진 작업을 처리하는 문제. 작업의 수행 시간이 중복되지 않도록 모든 작업을 가장 적은 수의 기계에 배정한다. 빠른 시작시간 작업을 우선(Earliest start time first)배정 알고리즘은 최적해를 구할 수 있다.
### 작업 스케줄링 알고리즘 수행과정
![img](https://user-images.githubusercontent.com/80511265/114723064-4f2cc280-9d75-11eb-9ff8-474ac1e6f4e1.png)
![img (1)](https://user-images.githubusercontent.com/80511265/114723092-55bb3a00-9d75-11eb-9802-26291aacd270.png)
![img (3)](https://user-images.githubusercontent.com/80511265/114723118-5ce24800-9d75-11eb-97de-6ca70279351f.png)

### 작업 스케줄링 알고리즘의 응용 분야
비즈니스 프로세싱, 공장 생산 공정, 강의실/세미나룸 배정, 컴퓨터 태스크 스케줄링 등등


## 2. 작업스케줄링
**'작업스케줄링(Job Scheduling)** 문제' 는 n개의 작업, 각 작업의 수행 시간 ti(i=1,2,3,4,5,...n) 그리고 m개의 동일한 기계가 주어질 때,</br>
모든 작업이 가장 빨리 종료되도록 작업을 기계(machine)에 배정하는 문제이다.</br>
단, 한 작업은 배정된 기계에서 연속적으로 수행, 기계는 1번에 하나의 작업만을 수행한다.</br> 
작업 스케줄링 문제를 해결하기 위한 가장 간단한 방법은 그리디 알고리즘을 이용해 푸는 것이다.</br>
즉, 배정된 작업이 가장 빨리 끝나는 기계에 새 작업을 배정해주는 것이다. 


## 3. 작업스케줄링 설계과정
작업의 수 n과 각 작업들의 시작 시간과 종료 시간이 기본적으로 입력값으로 들어온다.</br>
또한, 어떠한 경우에도 배치된 기계가 작업의 수보다 많을 수는 없다. 최대 기계 개수는 n값 만큼이 되는 것이다.</br>
우리에게 주어진 정보를 바탕으로 최적해를 구할 수 있는데, 시작시간, 종료시간, 작업의 길이를 바탕으로 알고리즘을 구현해주면 된다.</br>
네 가지 정도의 경우가 존재하는데, 빠른 시작시간 작업 우선, 빠른 종료시간 작업 우선, 짧은 작업 우선, 긴 작업 우선 이렇게가 있다.</br>
이 중에서도 **빠른 시작시간 작업**을 우선한 알고리즘으로 작업스케줄링을 설계하려 했다. 

```java
입력: n개의 작업
출력: 기계에 배정된 작업의 순서

작업 시작 전, 빠른 시작 시간으로 오름차순 정렬하여 배열에 삽입
배열[0] ~ 배열[n-1], i=0 초기화

while(i<n){
if(배열[i] 수행할 수 있는 기계 존재)
 존재시 배열[i]를 해당 기계에 배정
 존재를 안할시 새로운 기계를 찾아 배열[i]를 배정
 i++
}

기계에 배정된 결과 return
```
위와 같은 코드로 작업을 해줄 때, 시간복잡도는 n개 입력받은 작업을 정렬하는 데 O(nlogn) 시간이 걸리고,</br>
입력받은 n을 맞는 기계에 배정해주는 O(m)의 시간, while 루프가 입력만큼 수행되는 시간O(n)을 곱해줘 O(mn)의 시간이 걸린다.</br>
결국, 작업스케줄링에 시간 복잡도는 O(nlogn)+O(mn)이 걸리게 된다.
